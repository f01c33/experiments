// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createUsuario = `-- name: CreateUsuario :exec
INSERT INTO usuarios (nome,senha,tipo,email) VALUES (?,?,?,?)
`

type CreateUsuarioParams struct {
	Nome  string
	Senha string
	Tipo  string
	Email string
}

func (q *Queries) CreateUsuario(ctx context.Context, arg CreateUsuarioParams) error {
	_, err := q.db.ExecContext(ctx, createUsuario,
		arg.Nome,
		arg.Senha,
		arg.Tipo,
		arg.Email,
	)
	return err
}

const deletePost = `-- name: DeletePost :exec
DELETE FROM posts WHERE id = ?
`

func (q *Queries) DeletePost(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deletePost, id)
	return err
}

const deleteUsuario = `-- name: DeleteUsuario :exec
DELETE FROM usuarios WHERE id = ?
`

func (q *Queries) DeleteUsuario(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteUsuario, id)
	return err
}

const getLogins = `-- name: GetLogins :many
SELECT logins.id, usuario, dt, usuarios.id, nome, email, senha, codigo, tipo FROM logins LEFT JOIN usuarios ON logins.usuario=usuarios.id ORDER BY dt LIMIT ? OFFSET ?
`

type GetLoginsParams struct {
	Limit  int64
	Offset int64
}

type GetLoginsRow struct {
	ID      int64
	Usuario int64
	Dt      time.Time
	ID_2    sql.NullInt64
	Nome    sql.NullString
	Email   sql.NullString
	Senha   sql.NullString
	Codigo  sql.NullString
	Tipo    sql.NullString
}

func (q *Queries) GetLogins(ctx context.Context, arg GetLoginsParams) ([]GetLoginsRow, error) {
	rows, err := q.db.QueryContext(ctx, getLogins, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLoginsRow
	for rows.Next() {
		var i GetLoginsRow
		if err := rows.Scan(
			&i.ID,
			&i.Usuario,
			&i.Dt,
			&i.ID_2,
			&i.Nome,
			&i.Email,
			&i.Senha,
			&i.Codigo,
			&i.Tipo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPost = `-- name: GetPost :one













SELECT id, texto, titulo, dt FROM posts WHERE id = ? LIMIT 1
`

// -- name: GetCasa :one
// SELECT * FROM casas WHERE id = ? LIMIT 1;
// -- name: GetCasas :many
// SELECT * FROM casas ORDER BY nome;
// -- name: GetCasasPorNome :many
// SELECT * from casas WHERE nome LIKE ? ORDER BY nome;
// -- name: GetCasasPorCliente :many
// SELECT * FROM casas WHERE cliente = ? ORDER BY nome;
// -- name: CreateCasa :exec
// INSERT INTO casas (nome,cliente) VALUES (?,?);
// -- name: UpdateCasa :exec
// UPDATE casas SET nome=?,cliente=? WHERE id=?;
// -- name: DeleteCasa :exec
// DELETE FROM casas WHERE id = ?;
// -- name: GetCasaCliente :one
// SELECT * FROM casa_cliente WHERE id = ? LIMIT 1;
// -- name: GetCasasClientePorCliente :many
// SELECT * FROM casa_cliente WHERE cliente = ?;
// -- name: GetCasaClientePorCasa :one
// SELECT * FROM casa_cliente WHERE casa = ? LIMIT 1;
// -- name: InsertCasaCliente :exec
// INSERT INTO casa_cliente (cliente,casa) VALUES (?,?);
// -- name: UpdateCasaCliente :exec
// UPDATE casa_cliente SET cliente = ?, casa = ? WHERE id = ?;
// -- name: DeleteCasaCliente :exec
// DELETE FROM casa_cliente WHERE id=?;
func (q *Queries) GetPost(ctx context.Context, id int64) (Post, error) {
	row := q.db.QueryRowContext(ctx, getPost, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.Texto,
		&i.Titulo,
		&i.Dt,
	)
	return i, err
}

const getPosts = `-- name: GetPosts :many
SELECT id, texto, titulo, dt FROM posts ORDER BY dt LIMIT ? OFFSET ?
`

type GetPostsParams struct {
	Limit  int64
	Offset int64
}

func (q *Queries) GetPosts(ctx context.Context, arg GetPostsParams) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPosts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.Texto,
			&i.Titulo,
			&i.Dt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostsPorCasa = `-- name: GetPostsPorCasa :many
SELECT id, texto, titulo, dt FROM posts WHERE titulo = ? ORDER BY dt LIMIT ? OFFSET ?
`

type GetPostsPorCasaParams struct {
	Titulo string
	Limit  int64
	Offset int64
}

func (q *Queries) GetPostsPorCasa(ctx context.Context, arg GetPostsPorCasaParams) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPostsPorCasa, arg.Titulo, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.Texto,
			&i.Titulo,
			&i.Dt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsuario = `-- name: GetUsuario :one
SELECT id, nome, email, senha, codigo, tipo FROM usuarios WHERE id = ? LIMIT 1
`

func (q *Queries) GetUsuario(ctx context.Context, id int64) (Usuario, error) {
	row := q.db.QueryRowContext(ctx, getUsuario, id)
	var i Usuario
	err := row.Scan(
		&i.ID,
		&i.Nome,
		&i.Email,
		&i.Senha,
		&i.Codigo,
		&i.Tipo,
	)
	return i, err
}

const getUsuarioPorEmail = `-- name: GetUsuarioPorEmail :one
SELECT id, nome, email, senha, codigo, tipo from usuarios WHERE email LIKE ? LIMIT 1
`

func (q *Queries) GetUsuarioPorEmail(ctx context.Context, email string) (Usuario, error) {
	row := q.db.QueryRowContext(ctx, getUsuarioPorEmail, email)
	var i Usuario
	err := row.Scan(
		&i.ID,
		&i.Nome,
		&i.Email,
		&i.Senha,
		&i.Codigo,
		&i.Tipo,
	)
	return i, err
}

const getUsuarioPorNome = `-- name: GetUsuarioPorNome :many
SELECT id, nome, email, senha, codigo, tipo from usuarios WHERE nome LIKE ? ORDER BY nome
`

func (q *Queries) GetUsuarioPorNome(ctx context.Context, nome string) ([]Usuario, error) {
	rows, err := q.db.QueryContext(ctx, getUsuarioPorNome, nome)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Usuario
	for rows.Next() {
		var i Usuario
		if err := rows.Scan(
			&i.ID,
			&i.Nome,
			&i.Email,
			&i.Senha,
			&i.Codigo,
			&i.Tipo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsuarios = `-- name: GetUsuarios :many
SELECT id, nome, email, senha, codigo, tipo from usuarios ORDER BY nome
`

func (q *Queries) GetUsuarios(ctx context.Context) ([]Usuario, error) {
	rows, err := q.db.QueryContext(ctx, getUsuarios)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Usuario
	for rows.Next() {
		var i Usuario
		if err := rows.Scan(
			&i.ID,
			&i.Nome,
			&i.Email,
			&i.Senha,
			&i.Codigo,
			&i.Tipo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertLogins = `-- name: InsertLogins :exec



































INSERT INTO logins (usuario,dt) VALUES (?,?)
`

type InsertLoginsParams struct {
	Usuario int64
	Dt      time.Time
}

// -- name: GetPostPublico :one
// SELECT * FROM posts_publicos WHERE id = ? LIMIT 1;
// -- name: GetPostsPublicos :many
// SELECT * FROM posts_publicos ORDER BY dt LIMIT ? OFFSET ?;
// -- name: InsertPostPublico :one
// INSERT INTO posts_publicos (texto,dt) VALUES (?,?) RETURNING *;
// -- name: UpdatePostPublico :exec
// UPDATE posts_publicos SET texto = ?, dt = ? WHERE id = ?;
// -- name: DeletePostPublico :exec
// DELETE FROM posts_publicos WHERE id = ?;
// -- name: GetInsumo :one
// SELECT * FROM insumos WHERE id = ? LIMIT 1;
// -- name: GetInsumos :many
// SELECT * FROM insumos ORDER BY texto;
// -- name: InsertInsumo :exec
// INSERT INTO insumos (texto,preco) VALUES (?,?);
// -- name: UpdateInsumo :exec
// UPDATE insumos SET texto = ?, preco = ? WHERE id = ?;
// -- name: DeleteInsumo :exec
// DELETE FROM insumos WHERE id = ?;
// -- name: GetPostInsumo :one
// SELECT * FROM post_insumo WHERE id = ? LIMIT 1;
// -- name: GetPostInsumos :many
// SELECT * FROM post_insumo ORDER BY id;
// -- name: GetInsumosForPost :many
// SELECT insumos.* FROM insumos RIGHT JOIN post_insumo ON post_insumo.post = ? ORDER BY insumos.texto;
// -- name: InsertPostInsumo :exec
// INSERT INTO post_insumo (insumo,post) VALUES (?,?);
// -- name: UpdatePostInsumos :exec
// UPDATE post_insumo SET insumo = ?, post = ? WHERE id = ?;
// -- name: DeletePostInsumo :exec
// DELETE FROM post_insumo WHERE id = ?;
// -- name: GetRelatorioInsumo :one
// SELECT * FROM relatorio_insumo WHERE id = ? LIMIT 1;
// -- name: GetRelatorioInsumos :many
// SELECT * FROM relatorio_insumo ORDER BY id;
// -- name: GetInsumosForRelatorio :many
// SELECT insumos.* FROM insumos RIGHT JOIN relatorio_insumo ON relatorio_insumo.relatorio = ? ORDER BY insumos.texto;
// -- name: InsertRelatorioInsumo :exec
// INSERT INTO relatorio_insumo (insumo,relatorio) VALUES (?,?);
// -- name: UpdateRelatorioInsumos :exec
// UPDATE relatorio_insumo SET insumo = ?, relatorio = ? WHERE id = ?;
// -- name: DeleteRelatorioInsumo :exec
// DELETE FROM relatorio_insumo WHERE id = ?;
// -- name: GetArquivo :one
// SELECT * FROM arquivos WHERE id = ? LIMIT 1;
// -- name: GetArquivos :many
// SELECT * FROM arquivos ORDER BY dt LIMIT ? OFFSET ?;
// -- name: GetArquivosCasa :many
// SELECT * FROM arquivos WHERE casa = ? ORDER BY dt LIMIT ? OFFSET ?;
// -- name: GetArquivosRelatorio :many
// SELECT * FROM arquivos WHERE relatorio = ? ORDER BY dt LIMIT ? OFFSET ?;
// -- name: InsertArquivo :one
// INSERT INTO arquivos (arquivo, nome, relatorio, dt, casa) VALUES (?,?,?,?,?) RETURNING *;
// -- name: UpdateArquivo :exec
// UPDATE arquivos SET arquivo = ?, relatorio = ?, nome = ?, dt = ?, casa = ? WHERE id = ?;
// -- name: DeleteArquivo :exec
// DELETE FROM arquivos WHERE id = ?;
// -- name: CreateRelatorio :one
// INSERT INTO relatorios (texto,casa,dt) VALUES (?,?,?) RETURNING *;
// -- name: GetRelatorio :one
// SELECT * FROM relatorios WHERE id = ? LIMIT 1;
// -- name: GetRelatorios :many
// SELECT * FROM relatorios ORDER BY dt LIMIT ? OFFSET ?;
// -- name: GetRelatoriosCasa :many
// SELECT * FROM relatorios WHERE casa = ? ORDER BY dt LIMIT ? OFFSET ?;
// -- name: UpdateRelatorio :exec
// UPDATE relatorios SET texto = ?, casa = ?, dt = ? WHERE id = ?;
// -- name: DeleteRelatorio :exec
// DELETE FROM relatorios WHERE id = ?;
func (q *Queries) InsertLogins(ctx context.Context, arg InsertLoginsParams) error {
	_, err := q.db.ExecContext(ctx, insertLogins, arg.Usuario, arg.Dt)
	return err
}

const insertPost = `-- name: InsertPost :one
INSERT INTO posts (texto,dt,titulo) VALUES (?,?,?) RETURNING id, texto, titulo, dt
`

type InsertPostParams struct {
	Texto  string
	Dt     time.Time
	Titulo string
}

func (q *Queries) InsertPost(ctx context.Context, arg InsertPostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, insertPost, arg.Texto, arg.Dt, arg.Titulo)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.Texto,
		&i.Titulo,
		&i.Dt,
	)
	return i, err
}

const updatePost = `-- name: UpdatePost :exec
UPDATE posts SET texto = ?, dt = ?, titulo = ? WHERE id = ?
`

type UpdatePostParams struct {
	Texto  string
	Dt     time.Time
	Titulo string
	ID     int64
}

func (q *Queries) UpdatePost(ctx context.Context, arg UpdatePostParams) error {
	_, err := q.db.ExecContext(ctx, updatePost,
		arg.Texto,
		arg.Dt,
		arg.Titulo,
		arg.ID,
	)
	return err
}

const updateUsuario = `-- name: UpdateUsuario :exec
UPDATE usuarios SET nome = ?, email = ?, tipo = ? WHERE id = ?
`

type UpdateUsuarioParams struct {
	Nome  string
	Email string
	Tipo  string
	ID    int64
}

func (q *Queries) UpdateUsuario(ctx context.Context, arg UpdateUsuarioParams) error {
	_, err := q.db.ExecContext(ctx, updateUsuario,
		arg.Nome,
		arg.Email,
		arg.Tipo,
		arg.ID,
	)
	return err
}

const updateUsuarioRaw = `-- name: UpdateUsuarioRaw :exec
UPDATE usuarios SET nome = ?, email = ?, tipo = ?, senha = ?, codigo = ? WHERE id = ?
`

type UpdateUsuarioRawParams struct {
	Nome   string
	Email  string
	Tipo   string
	Senha  string
	Codigo sql.NullString
	ID     int64
}

func (q *Queries) UpdateUsuarioRaw(ctx context.Context, arg UpdateUsuarioRawParams) error {
	_, err := q.db.ExecContext(ctx, updateUsuarioRaw,
		arg.Nome,
		arg.Email,
		arg.Tipo,
		arg.Senha,
		arg.Codigo,
		arg.ID,
	)
	return err
}
